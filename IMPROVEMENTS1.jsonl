{"rank":1,"category":"correctness","subcategory":"cache","issue":"QueryCache.get/put blocks mis-indented causing logic to execute outside lock","impact":"HIGH","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":2338,"current":"        answer, metadata, timestamp = self.cache[key]\n        metadata_timestamp = metadata.get(\"timestamp\")","proposed":"Move timestamp enrichment and expiry checks inside the with-block or delegate to clockify_rag.caching.QueryCache","rationale":"Statements currently run after the context manager closes, leading to race conditions and AttributeError when metadata is None","implementation":"Import QueryCache from clockify_rag.caching and delete the local implementation, or fix indentation and ensure metadata defaults are handled","expected_gain":"Restores cache correctness and prevents runtime crashes under load","references":["tests/test_query_cache.py"]}
{"rank":2,"category":"correctness","subcategory":"retrieval","issue":"FAISS branch has stray parentheses and dead max() call breaking control flow","impact":"HIGH","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":1577,"current":"            dense_computed = int(remaining_idx.size)\n            max(ANN_CANDIDATE_MIN, top_k * FAISS_CANDIDATE_MULTIPLIER)\n        )","proposed":"Remove orphaned max(...) line and closing parenthesis; ensure block ends after dense_computed assignment","rationale":"As written the code raises SyntaxError/IndentationError and FAISS retrieval cannot execute","implementation":"Rewrite FAISS branch to compute candidate_idx and dense_scores cleanly, mirroring clockify_rag.indexing behaviour","expected_gain":"Restores ANN acceleration (~10x faster retrieval when FAISS available)","references":["clockify_rag/indexing.py"]}
{"rank":3,"category":"architecture","subcategory":"reuse","issue":"CLI reimplements caching, rate limiting, and HTTP session helpers instead of importing shared modules","impact":"HIGH","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":68,"current":"from clockify_rag.caching import QueryCache, RateLimiter\n...\nclass QueryCache: ...","proposed":"Delete duplicate class definitions and rely on clockify_rag.caching.QueryCache/RateLimiter and http_utils.get_session","rationale":"Duplication caused the current regression and increases maintenance cost","implementation":"Remove custom classes, update call sites, and adjust tests to use shared implementations","expected_gain":"Eliminates divergence and cuts cache/rate-limit bugs by reusing battle-tested code","references":["clockify_rag/caching.py"]}
{"rank":4,"category":"testing","subcategory":"integration","issue":"No integration test covers full retrieve->pack->ask flow in CLI","impact":"HIGH","effort":"MEDIUM","file":"tests/test_retrieval.py","line":15,"current":"selected, scores = retrieve(question, sample_chunks, sample_embeddings, sample_bm25, top_k=k)","proposed":"Add test that invokes clockify_support_cli_final.answer_once with in-memory fixtures and asserts JSON schema","rationale":"Syntax regressions in retrieve() and QueryCache went unnoticed because CLI path is untested","implementation":"Create fixture building fake index artifacts, then call answer_once(..., debug=True) and validate response","expected_gain":"Prevents future catastrophic regressions before release","references":["tests/test_answer_once_logging.py"]}
{"rank":5,"category":"correctness","subcategory":"retrieval","issue":"HNSW fallback path never initializes dense_scores list leading to UnboundLocalError","impact":"HIGH","effort":"LOW","file":"clockify_support_cli_final.py","line":1592,"current":"    elif hnsw:\n        _, cand = hnsw.knn_query(...)","proposed":"Set dense_scores = dense_scores_full[candidate_idx] or reuse DenseScoreStore with full array when using HNSW","rationale":"Later code expects dense_scores when dense_scores_full is None","implementation":"After computing dense_scores_full in HNSW branch, assign dense_scores = dense_scores_full[candidate_idx]","expected_gain":"Ensures non-FAISS ANN path works and avoids runtime NameError","references":["tests/test_retrieval.py"]}
{"rank":6,"category":"correctness","subcategory":"retrieval","issue":"Linear fallback duplicates candidate_idx assignment twice and wastes computation","impact":"MEDIUM","effort":"LOW","file":"clockify_support_cli_final.py","line":1600,"current":"        dense_scores_full = vecs_n.dot(qv_n)\n        ...\n        candidate_idx = np.arange(n_chunks)\n        dense_scores = vecs_n.dot(qv_n)\n        candidate_idx = np.arange(len(chunks)).tolist()","proposed":"Compute dense_scores once, reuse numpy array, and convert to list a single time","rationale":"Duplicate work doubles dot products and can return numpy array instead of list","implementation":"Set dense_scores = dense_scores_full and candidate_idx = np.arange(n_chunks).tolist()","expected_gain":"~2x speedup on pure dense fallback and consistent types","references":["benchmark.py"]}
{"rank":7,"category":"correctness","subcategory":"retrieval","issue":"candidate_idx_array built from list but not deduplicated, allowing duplicates from FAISS","impact":"MEDIUM","effort":"LOW","file":"clockify_support_cli_final.py","line":1611,"current":"candidate_idx_array = np.array(candidate_idx, dtype=np.int32)","proposed":"Wrap candidate_idx = sorted(set(candidate_idx)) before conversion","rationale":"Duplicate ids reduce diversity and break dedup heuristics","implementation":"Apply np.unique or Python set to candidate_idx before continuing","expected_gain":"Improves retrieval diversity and reduces redundant packing","references":["tests/test_retrieval.py"]}
{"rank":8,"category":"correctness","subcategory":"retrieval","issue":"hybrid_full else branch only fills candidate indices leaving zeros elsewhere","impact":"MEDIUM","effort":"LOW","file":"clockify_support_cli_final.py","line":1648,"current":"        hybrid_full = np.zeros(len(chunks), dtype=\"float32\")\n        for idx, score in zip(candidate_idx, hybrid):","proposed":"Initialize hybrid_full with -inf or reuse zs arrays to avoid biasing KPI logs","rationale":"Zero scores mislead downstream filters and caching heuristics","implementation":"Set hybrid_full[:] = -1 and fill candidates, or compute full array from zs_dense_full when available","expected_gain":"More accurate coverage thresholds and caching stats","references":["clockify_support_cli_final.py"]}
{"rank":9,"category":"correctness","subcategory":"packing","issue":"pack_snippets truncation appends marker without adjusting used token count","impact":"MEDIUM","effort":"LOW","file":"clockify_support_cli_final.py","line":1820,"current":"        out[0] = out[0].replace(\"]\", \" [TRUNCATED]]\", 1)","proposed":"Recompute used token estimate after truncating first snippet to keep KPI accurate","rationale":"Token budget logging becomes inaccurate when first snippet is truncated","implementation":"After truncation recalc approx_tokens for first snippet and update `used`","expected_gain":"Accurate KPI reporting and downstream analytics","references":["tests/test_packer.py"]}
{"rank":10,"category":"correctness","subcategory":"sanitization","issue":"sanitize_question only checks simple substrings for injection","impact":"MEDIUM","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":2174,"current":"    suspicious_patterns = [ '<script', 'javascript:', ... ]","proposed":"Expand detection with regex for triple-brace template injection and common jailbreak phrases; log refusals","rationale":"Sophisticated prompt injections bypass simple substrings","implementation":"Add regex list and centralize in security module with unit tests","expected_gain":"Reduces chance of prompt-injection exploitation","references":["tests/test_sanitization.py"]}
{"rank":11,"category":"performance","subcategory":"caching","issue":"Embedding cache writes entire cache on every build even for few updates","impact":"MEDIUM","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":1991,"current":"        if cache_miss_indices:\n            save_embedding_cache(emb_cache)","proposed":"Write incremental updates by appending only new entries or using sqlite","rationale":"Large caches rewrite MBs of data causing slow builds","implementation":"Maintain append-only log or checksum to persist only new hashes","expected_gain":"30-50% faster incremental builds for large KB","references":["clockify_rag/embedding.py"]}
{"rank":12,"category":"performance","subcategory":"retrieval","issue":"DenseScoreStore always materializes full np.dot when qv/vecs provided","impact":"MEDIUM","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":1489,"current":"                self._full = self._vecs.dot(self._qv).astype(\"float32\")","proposed":"Cache dot product for requested indices only and lazily compute full array when needed","rationale":"For small top_k we waste time computing full dot product","implementation":"Store vecs and qv, compute slice on demand using np.dot for subset","expected_gain":"Reduces latency for large corpora when only few scores needed","references":["benchmark.py"]}
{"rank":13,"category":"evaluation","subcategory":"metrics","issue":"eval.py lacks relevance metrics and depends on live Ollama","impact":"HIGH","effort":"MEDIUM","file":"eval.py","line":210,"current":"# TODO: compute metrics","proposed":"Implement offline evaluation using stored embeddings and compute MRR/NDCG/accuracy with ground truth","rationale":"Without metrics there is no regression signal for retrieval quality","implementation":"Load eval_dataset.jsonl, compare model answers to references, output metrics JSON","expected_gain":"Enables CI gating on retrieval quality","references":["eval_dataset.jsonl"]}
{"rank":14,"category":"documentation","subcategory":"consolidation","issue":"Dozens of stale deliverable markdowns confuse onboarding","impact":"MEDIUM","effort":"MEDIUM","file":"README.md","line":1,"current":"Multiple conflicting readiness statements across repo","proposed":"Archive legacy docs into /archive and author single source README + operations guide","rationale":"Conflicting documentation undermines trust and slows onboarding","implementation":"Create docs/ with up-to-date guides, update README links, delete superseded files","expected_gain":"Cuts onboarding time and reduces compliance risk","references":["PROJECT_STRUCTURE.md"]}
{"rank":15,"category":"security","subcategory":"network","issue":"deepseek_ollama_shim.py allows unauthenticated access by default","impact":"MEDIUM","effort":"LOW","file":"deepseek_ollama_shim.py","line":69,"current":"if AUTH_TOKEN: ...","proposed":"Require auth token unless explicitly disabled via env flag and log rejected attempts","rationale":"Open shim can leak paid API key and expose embeddings endpoint","implementation":"Default AUTH_TOKEN to random value or abort startup when missing","expected_gain":"Prevents accidental exposure of DeepSeek API","references":["deepseek_ollama_shim.py"]}
{"rank":16,"category":"dependency","subcategory":"pinning","issue":"requirements.txt and pyproject.toml diverge and omit minimum versions","impact":"MEDIUM","effort":"LOW","file":"requirements.txt","line":1,"current":"numpy","proposed":"Pin compatible versions and sync with pyproject (poetry/uv) to avoid surprise upgrades","rationale":"Divergent pins cause reproducibility failures across environments","implementation":"Generate lockfile, update requirements*.txt and pyproject extras","expected_gain":"Deterministic builds across CI and developer laptops","references":["pyproject.toml"]}
{"rank":17,"category":"performance","subcategory":"benchmarking","issue":"benchmark.py assumes live Ollama even in CI","impact":"MEDIUM","effort":"LOW","file":"benchmark.py","line":33,"current":"if os.environ.get(\"BENCHMARK_FAKE_REMOTE\") == \"1\": ...","proposed":"Default to fake remote unless explicit flag set, and skip long benchmarks in CI","rationale":"Current default hits network and fails in sandboxed CI","implementation":"Flip condition to opt-in for real remote and integrate with pytest-benchmark","expected_gain":"Reliable performance checks without external dependency","references":["scripts/benchmark.sh"]}
{"rank":18,"category":"testing","subcategory":"http","issue":"http_utils._mount_retries lacks direct unit tests","impact":"MEDIUM","effort":"LOW","file":"clockify_rag/http_utils.py","line":19,"current":"def _mount_retries(sess: requests.Session, retries: int):","proposed":"Add tests that verify adapter pool sizes and retry settings with urllib3 v1/v2","rationale":"Recent regressions could silently remove retry/backoff behaviour","implementation":"Use requests_mock to inspect mounted adapters in tests/test_http_utils.py","expected_gain":"Ensures reliability of retry/backoff across Python versions","references":["clockify_rag/http_utils.py"]}
{"rank":19,"category":"developer-experience","subcategory":"setup","issue":"setup.sh mixes macOS and Linux package managers with no gating","impact":"MEDIUM","effort":"LOW","file":"setup.sh","line":10,"current":"brew install ...; apt-get install ...","proposed":"Detect platform and run appropriate installer block, otherwise warn","rationale":"Script currently fails midway on any platform","implementation":"Use case statement on uname and provide manual instructions for unsupported OS","expected_gain":"Smoother onboarding and fewer support tickets","references":["setup.sh"]}
{"rank":20,"category":"data","subcategory":"artifacts","issue":"chunk_title_map.json is 9k lines with no regeneration script documented","impact":"LOW","effort":"LOW","file":"chunk_title_map.json","line":1,"current":"{\"chunk_id\": \"...\", ...}","proposed":"Document regeneration process and compress/store as gzip to reduce repo bloat","rationale":"Large static file easily drifts from current KB and bloats repo","implementation":"Add README section and update generate_chunk_title_map.py to write compressed output","expected_gain":"Smaller repo footprint and easier rebuilds","references":["scripts/generate_chunk_title_map.py"]}
