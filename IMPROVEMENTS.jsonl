{"rank":1,"category":"correctness","subcategory":"caching","issue":"QueryCache.get ignores retrieval parameters causing TypeError","impact":"HIGH","effort":"LOW","file":"clockify_support_cli_final.py","line":2417,"current":"def get(self, question: str):","proposed":"def get(self, question: str, params: dict | None = None):","rationale":"answer_once passes retrieval parameters but the cache API drops them, so repeated queries crash and stale results leak across settings.","implementation":"Adopt the parameter-aware hashing implementation from clockify_rag.caching.QueryCache, including sorted param tuples.","expected_gain":"Restore stable caching for repeated queries and prevent runtime exceptions.","references":["clockify_support_cli_final.py:L2417-L2445","clockify_support_cli_final.py:L2812-L2826","clockify_rag/caching.py:L70-L147"]}
{"rank":2,"category":"correctness","subcategory":"caching","issue":"QueryCache.put cannot accept retrieval parameters","impact":"HIGH","effort":"LOW","file":"clockify_support_cli_final.py","line":2446,"current":"def put(self, question: str, answer: str, metadata: dict):","proposed":"def put(self, question: str, answer: str, metadata: dict, params: dict | None = None):","rationale":"answer_once attempts to store cache entries with retrieval metadata; without params the call raises and cache never warms.","implementation":"Mirror clockify_rag.caching.QueryCache.put, hashing question+params and storing timestamps.","expected_gain":"Eliminate cache write failures when using non-default retrieval knobs.","references":["clockify_support_cli_final.py:L2446-L2492","clockify_support_cli_final.py:L2923-L3040","clockify_rag/caching.py:L149-L170"]}
{"rank":3,"category":"architecture","subcategory":"reuse","issue":"CLI redefines QueryCache and RateLimiter instead of importing maintained versions","impact":"HIGH","effort":"MEDIUM","file":"clockify_support_cli_final.py","line":2280,"current":"class RateLimiter: ... class QueryCache: ...","proposed":"Delete duplicate class implementations and import from clockify_rag.caching","rationale":"Duplication caused the API drift that broke caching; centralising in the package prevents future divergence.","implementation":"Remove local class definitions and rely on the existing import at the top of the module.","expected_gain":"Reduce maintenance risk and keep CLI aligned with library behaviour.","references":["clockify_support_cli_final.py:L2280-L2526","clockify_rag/caching.py:L1-L210"]}
{"rank":4,"category":"correctness","subcategory":"reproducibility","issue":"FAISS training on macOS arm64 uses np.random.choice without deterministic seeding","impact":"MED","effort":"LOW","file":"clockify_support_cli_final.py","line":427,"current":"train_indices = np.random.choice(len(vecs), m1_train_size, replace=False)","proposed":"rng = np.random.default_rng(DEFAULT_SEED); train_indices = rng.choice(len(vecs), m1_train_size, replace=False)","rationale":"Non-deterministic IVF training produces different centroids across builds, complicating regression testing.","implementation":"Instantiate a seeded Generator for both arm64 and default branches, mirroring clockify_rag.indexing.","expected_gain":"Deterministic ANN indexes and reproducible retrieval scores across environments.","references":["clockify_support_cli_final.py:L394-L454","clockify_rag/indexing.py:L24-L78"]}
{"rank":5,"category":"performance","subcategory":"embedding","issue":"Parallel embed_texts reuses a single requests.Session across threads","impact":"HIGH","effort":"MEDIUM","file":"clockify_rag/embedding.py","line":113,"current":"sess = get_session(retries=retries) ... executor.submit(_embed_single_text, i, text, sess, total)","proposed":"Create thread-local sessions (e.g., use requests.Session per worker or wrap get_session in thread-local factory)","rationale":"requests.Session is not thread-safe; sharing it across ThreadPoolExecutor can corrupt responses and hang builds.","implementation":"Wrap the worker call to acquire its own session from a thread-local cache or call requests.post without shared session.","expected_gain":"Reliable concurrent embedding generation with fewer HTTP errors under load.","references":["clockify_rag/embedding.py:L113-L192"]}
{"rank":6,"category":"performance","subcategory":"embedding","issue":"ThreadPool submits one future per chunk leading to thousands of in-flight requests","impact":"MED","effort":"MED","file":"clockify_rag/embedding.py","line":165,"current":"futures = {executor.submit(_embed_single_text, i, text, sess, total): i for i, text in enumerate(texts)}","proposed":"Chunk indices into batches (<=EMB_MAX_WORKERS*EMB_BATCH_SIZE) and submit iteratively","rationale":"Creating a future for every chunk exhausts memory and sockets on large corpora; batching maintains backpressure.","implementation":"Iterate over slices of texts, submitting at most EMB_MAX_WORKERS tasks at once and waiting before scheduling more.","expected_gain":"Lower peak memory and socket usage during index builds, enabling larger corpora.","references":["clockify_rag/embedding.py:L165-L185"]}
{"rank":7,"category":"maintainability","subcategory":"dead-code","issue":"ensure_index_ready defined twice with partial implementation","impact":"MED","effort":"LOW","file":"clockify_support_cli_final.py","line":3324,"current":"def ensure_index_ready(...): artifacts = [...] (incomplete) ... def ensure_index_ready(...): ...","proposed":"Remove the first incomplete definition and keep a single well-tested implementation","rationale":"Duplicate definitions confuse readers and risk future edits touching the wrong version.","implementation":"Delete lines 3324-3328 or merge logic into the surviving function.","expected_gain":"Clear control flow and fewer maintenance traps.","references":["clockify_support_cli_final.py:L3324-L3361"]}
{"rank":8,"category":"architecture","subcategory":"modularity","issue":"CLI duplicates chunk parsing/embedding/indexing logic already exported by clockify_rag","impact":"HIGH","effort":"HIGH","file":"clockify_support_cli_final.py","line":1114,"current":"Standalone parse_articles, sliding_chunks, embed_texts, build, retrieve implementations","proposed":"Refactor CLI to call clockify_rag.chunking, embedding, indexing, and future retrieval modules","rationale":"Duplicated logic diverges (e.g., caching bug) and inflates maintenance cost; the package is meant to house reusable components.","implementation":"Introduce thin wrappers that import from clockify_rag and delete redundant functions.","expected_gain":"Single source of truth for chunking/retrieval and smaller CLI surface.","references":["clockify_support_cli_final.py:L1114-L2002","clockify_rag/chunking.py:L1-L160","clockify_rag/indexing.py:L1-L260"]}
{"rank":9,"category":"performance","subcategory":"logging","issue":"Query log writes full chunk bodies even when answer logging is disabled","impact":"MED","effort":"LOW","file":"clockify_support_cli_final.py","line":2514,"current":"retrieved_chunks.append({"chunk": chunk, ...})","proposed":"Omit chunk text unless LOG_QUERY_INCLUDE_ANSWER is true or add a size cap","rationale":"Storing entire chunk payloads bloats logs and leaks context when only metadata is needed.","implementation":"Conditionally include chunk bodies or replace with chunk IDs/sections depending on configuration.","expected_gain":"Smaller log files and reduced risk of leaking sensitive content.","references":["clockify_support_cli_final.py:L2514-L2560","clockify_rag/config.py:L60-L90"]}
{"rank":10,"category":"correctness","subcategory":"citations","issue":"generate_llm_answer only warns when citations are missing","impact":"MED","effort":"MED","file":"clockify_support_cli_final.py","line":2688,"current":"if not has_citations ... logger.warning(...)","proposed":"Optionally replace answer with REFUSAL_STR when citations are absent (behind flag)","rationale":"Silent acceptance of uncited answers increases hallucination risk; offering a strict mode improves trust.","implementation":"Add config flag (e.g., STRICT_CITATIONS) to convert the warning into a refusal path.","expected_gain":"Improved answer reliability in regulated environments.","references":["clockify_support_cli_final.py:L2688-L2764"]}
{"rank":11,"category":"developer-experience","subcategory":"warmup","issue":"Warm-up swallows errors and provides no user feedback","impact":"LOW","effort":"LOW","file":"clockify_support_cli_final.py","line":3428,"current":"except Exception as e: logger.debug(f"Warm-up skipped: {e}")","proposed":"Log a warning or surface warm-up failure in startup banner","rationale":"Operators need to know when Ollama endpoints are unavailable instead of silently skipping warm-up.","implementation":"Raise log level to warning and print a short message before entering the REPL.","expected_gain":"Faster diagnosis of connectivity issues before first query.","references":["clockify_support_cli_final.py:L3428-L3454"]}
{"rank":12,"category":"testing","subcategory":"regression","issue":"Missing automated test for cache parameter hashing","impact":"HIGH","effort":"LOW","file":"tests/test_answer_once_logging.py","line":68,"current":"test only checks cache hit without varying retrieval knobs","proposed":"Add test invoking answer_once twice with different top_k/pack_top to ensure cache differentiates entries","rationale":"Would have caught the params bug immediately and will guard future refactors.","implementation":"Create new test that mutates retrieval arguments and asserts separate cache entries.","expected_gain":"Prevents regressions in cache key logic.","references":["tests/test_answer_once_logging.py:L7-L94","clockify_support_cli_final.py:L2812-L3040"]}
{"rank":13,"category":"documentation","subcategory":"cleanup","issue":"Legacy audit deliverables clutter repository and confuse current state","impact":"MED","effort":"MED","file":"ANALYSIS_REPORT1.md","line":1,"current":"Multiple historical reports and summaries stored in repo","proposed":"Archive or remove superseded documents, keeping one authoritative set","rationale":"Engineers waste time reconciling conflicting guidance; doc bloat obscures active instructions.","implementation":"Move legacy docs to /docs/archive or prune from repo, linking to latest analysis instead.","expected_gain":"Clear onboarding path and lower maintenance overhead.","references":["ANALYSIS_REPORT1.md:L1-L120","README.md:L1-L120"]}
{"rank":14,"category":"configuration","subcategory":"docs","issue":"Environment toggles (ANN, logging, caching) undocumented in user guides","impact":"LOW","effort":"LOW","file":"README.md","line":1,"current":"README lists commands but omits ENV knobs like ALPHA, ANN_NLIST, RAG_LOG_INCLUDE_ANSWER","proposed":"Add configuration section summarising key environment variables and defaults","rationale":"Operators need a single reference for tuning retrieval and logging behaviour.","implementation":"Extend README Quick Start with a table describing relevant env vars sourced from clockify_rag.config.","expected_gain":"Better operator awareness and fewer misconfigurations.","references":["README.md:L1-L160","clockify_rag/config.py:L1-L120"]}
{"rank":15,"category":"security","subcategory":"logging","issue":"deepseek_ollama_shim audit log lacks rotation or size guard","impact":"LOW","effort":"MED","file":"deepseek_ollama_shim.py","line":44,"current":"audit_log writes to AUDIT_LOG_FILE without bounds","proposed":"Implement log rotation or max size check (e.g., using RotatingFileHandler)","rationale":"Long-running shim will produce unbounded audit logs; rotation prevents disk exhaustion.","implementation":"Swap manual open() for logging.handlers.RotatingFileHandler with configurable size/backup count.","expected_gain":"Safer long-term shim operation without manual cleanup.","references":["deepseek_ollama_shim.py:L44-L92"]}
{"rank":16,"category":"performance","subcategory":"retrieval","issue":"bm25_scores recomputes scores for entire corpus even when FAISS candidates cover most results","impact":"MED","effort":"MED","file":"clockify_support_cli_final.py","line":1400,"current":"bm_scores_full = bm25_scores(expanded_question, bm, top_k=top_k * 3)","proposed":"Compute BM25 only for candidate set (e.g., restrict to candidate_idx) when ANN provides shortlist","rationale":"Sparse scoring across the whole corpus adds latency; focusing on ANN candidates retains quality with less work.","implementation":"Add option to bm25_scores to accept candidate indices and fallback to full scan when ANN disabled.","expected_gain":"Lower retrieval latency on large corpora while keeping hybrid scoring accuracy.","references":["clockify_support_cli_final.py:L1400-L1492","clockify_support_cli_final.py:L1624-L1696"]}
{"rank":17,"category":"architecture","subcategory":"package","issue":"No dedicated retrieval module inside clockify_rag","impact":"HIGH","effort":"HIGH","file":"clockify_rag","line":1,"current":"retrieve/pack/answer logic only lives in CLI","proposed":"Add clockify_rag.retrieval exposing retrieve, pack_snippets, answer_once","rationale":"Central module enables reuse by CLI, API servers, and evaluation harness without copy/paste.","implementation":"Extract retrieval-related functions into new module and adjust imports accordingly.","expected_gain":"Shared improvements and easier testing of retrieval pipeline.","references":["clockify_support_cli_final.py:L1400-L2100","clockify_rag/__init__.py:L12-L52"]}
{"rank":18,"category":"testing","subcategory":"integration","issue":"Lack of concurrency stress test for embedding thread pool","impact":"MED","effort":"MED","file":"tests","line":1,"current":"Tests mock retrieval but never exercise parallel embedding","proposed":"Add test harness using dummy HTTP server to validate ThreadPool concurrency and session isolation","rationale":"Will detect regressions in embedding concurrency fixes and ensure caching works under load.","implementation":"Create pytest that spins up simple Flask server returning deterministic embeddings and runs embed_texts with large input.","expected_gain":"Confidence in high-volume indexing scenarios.","references":["clockify_rag/embedding.py:L113-L192","tests/test_thread_safety.py:L1-L120"]}
{"rank":19,"category":"developer-experience","subcategory":"cli","issue":"chat_repl warm-up blocks REPL startup","impact":"LOW","effort":"MED","file":"clockify_support_cli_final.py","line":3365,"current":"warmup_on_startup() called synchronously before prompt","proposed":"Move warm-up to background thread or optional command","rationale":"Blocking network requests delay first user interaction; asynchronous warm-up keeps UX snappy.","implementation":"Spawn a daemon thread to run warmup_on_startup after printing banner or gate behind --warmup flag.","expected_gain":"Faster perceived startup without sacrificing cache priming.","references":["clockify_support_cli_final.py:L3365-L3454"]}
{"rank":20,"category":"documentation","subcategory":"quickstart","issue":"Multiple Quickstart guides conflict","impact":"MED","effort":"MED","file":"SUPPORT_CLI_QUICKSTART.md","line":1,"current":"Parallel quickstart docs (README, QUICKSTART, SUPPORT_CLI_QUICKSTART) diverge","proposed":"Merge into single authoritative Quickstart and mark others as archived","rationale":"Conflicting instructions confuse new users and slow onboarding.","implementation":"Consolidate installation/run steps into README and replace other files with short links or archive notice.","expected_gain":"Streamlined onboarding and reduced doc maintenance.","references":["SUPPORT_CLI_QUICKSTART.md:L1-L200","README.md:L1-L160","QUICKSTART.md:L1-L200"]}
